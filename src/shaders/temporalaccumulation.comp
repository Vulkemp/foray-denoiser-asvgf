#version 430
#extension GL_KHR_vulkan_glsl : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "asvgf_shared.glsl"
#include "debug.glsl.h"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

//Inputs
layout(rgba16f, binding = 0) uniform readonly image2D PrimaryInput;

layout(rg16f, binding = 1) uniform readonly image2D GbufferMotionVec;

layout(rg16f, binding = 2) uniform readonly image2D GbufferPositions;

layout(rg16f, binding = 3) uniform readonly image2D HistoryGbufferPositions;

layout(rgba16f, binding = 4) uniform readonly image2D GbufferNormals;

layout(rgba16f, binding = 5) uniform readonly image2D HistoryGbufferNormals;

layout(r16ui, binding = 6) uniform readonly uimage2D GbufferMeshInstanceIdx;

layout(r16ui, binding = 7) uniform readonly uimage2D HistoryGbufferMeshInstanceIdx;

//Output
layout(rgba16f, binding = 8) uniform image2DArray AccumulatedColor; //ReadWrite access

layout(rg16f, binding = 9) uniform image2DArray AccumulatedMoments; //ReadWrite access

layout(r16f, binding = 10) uniform image2DArray AccumulatedHistoryLength; //ReadWrite access

layout(rg16f, binding = 11) uniform readonly image2DArray LuminanceMaxDiff;

layout(rgba16f, binding = 12) uniform writeonly image2D DebugOutput;

layout(push_constant) uniform push_constant_t
{
    // Read array index
    uint ReadIdx;
    // Write array index
    uint WriteIdx;
    // Maximum deviation of the sinus of previous and current normal (Default 0.05)
    float MaxPositionDifference;
    // Deviation multiplier (Default 1.0)
    float DepthDeviationToleranceMultiplier;
    // Combined Weight Threshhold (Default 0.01)
    float WeightThreshhold;
    // Minimum weight assigned to new data
    float MinNewDataWeight;
    uint LuminanceMaxDiffReadIdx;
    uint EnableHistory;
    uint DebugMode;
} PushC;

bool testInsideScreen(in ivec2 samplePos, in ivec2 renderSize)
{
    return samplePos.x >= 0 && samplePos.x < renderSize.x && samplePos.y >= 0 && samplePos.y < renderSize.y;
}

bool testNormalDeviation(in vec3 currNormal, in vec3 prevNormal)
{
    return (1 - dot(currNormal, prevNormal)) <= PushC.MaxPositionDifference;
}

bool testPositions(in vec3 currPositions, in vec3 prevPositions)
{
    vec3 difference = prevPositions - currPositions;

    float maxDiffSquared = PushC.MaxPositionDifference * PushC.MaxPositionDifference;

    return dot(difference, difference) < maxDiffSquared;
}

void main() {
    ivec2 currTexel = ivec2(gl_GlobalInvocationID.xy);

    ivec2 renderSize = imageSize(GbufferMotionVec);

    vec2 motionVec = imageLoad(GbufferMotionVec, currTexel).xy;

    vec2 prevTexel = currTexel + motionVec * imageSize(PrimaryInput).xy;
    
    vec3 position = imageLoad(GbufferPositions, currTexel).xyz;

    vec2 prevPosSubPixel = fract(prevTexel);

    vec3 currColor = imageLoad(PrimaryInput, currTexel).rgb;

    vec3 currNormal = imageLoad(GbufferNormals, currTexel).rgb;


    uint meshInstanceIdx = imageLoad(GbufferMeshInstanceIdx, currTexel).x;

    float luminance = calcLuminance(currColor);

    vec2 currMoments = vec2(luminance, luminance * luminance);

    vec3 prevColor = vec3(0);
    vec2 prevMoments = vec2(0);
    float historyLength = 0.f;
    float summedWeight = 0.f;

    if (PushC.EnableHistory > 0)
    { // Read history data w/ bilinear interpolation
    	for(int y = 0; y <= 1; y++) {
    		for(int x = 0; x <= 1; x++) {
    			ivec2 samplePos    = ivec2(prevTexel + ivec2(x, y));
    			vec3 prevPosition    = imageLoad(HistoryGbufferPositions, samplePos).xyz;
    			vec3  prevNormal   = imageLoad(HistoryGbufferNormals, samplePos).rgb;
    			uint prevMeshInstanceIdx  = imageLoad(HistoryGbufferMeshInstanceIdx, samplePos).x;

    			bool accept = true;
    			accept = accept && testInsideScreen(samplePos, renderSize); // discard outside viewport
    			accept = accept && testNormalDeviation(currNormal, prevNormal); // discard if normal deviates too far (18 degrees max)     
                accept = accept && testPositions(position, prevPosition); // Discard if world space positions differ to much
    			accept = accept && meshInstanceIdx == prevMeshInstanceIdx; // Check mesh id

    			if(accept) {
    				float weight = (x == 0 ? (1.0 - prevPosSubPixel.x) : prevPosSubPixel.x)
    					    * (y == 0 ? (1.0 - prevPosSubPixel.y) : prevPosSubPixel.y); // bilinear weight
    				prevColor   += imageLoad(AccumulatedColor, ivec3(samplePos, PushC.ReadIdx)).rgb * weight;
    				prevMoments += imageLoad(AccumulatedMoments, ivec3(samplePos, PushC.ReadIdx)).rg * weight;
    				historyLength += imageLoad(AccumulatedHistoryLength, ivec3(samplePos, PushC.ReadIdx)).r * weight;
    				summedWeight += weight;
    			}
    		}
        }
    }


    // TODO: Implement Antilag
    float antilagAlpha = 0.f;
    {
        const int gradientFilterRadius = 2;

        for(int y = -gradientFilterRadius; y <= gradientFilterRadius; y++) {
			for(int x = -gradientFilterRadius; x <= gradientFilterRadius; x++) {
                ivec3 samplePos = ivec3(currTexel / STRATASIZE + ivec2(x, y), PushC.LuminanceMaxDiffReadIdx);
                vec2 luminanceMaxDiff = imageLoad(LuminanceMaxDiff, samplePos).rg;
                float lumMax = luminanceMaxDiff.r;
                float lumDiff = luminanceMaxDiff.g;

				float a = clamp(abs(lumMax > 1e-4 ? abs(lumDiff) / lumMax : 0.0), 0.0, 200.0);

				antilagAlpha = max(antilagAlpha, a);
			}
		}
    }

    clamp(antilagAlpha, 0.0, 1.0);
	if(isnan(antilagAlpha))
    {
		antilagAlpha = 1.0;
    }


    if (summedWeight > PushC.WeightThreshhold)
    {
        // Alpha values: [0...1], where 0 == only history data, 1 == only new data
        prevColor /= summedWeight;
        prevMoments /= summedWeight;
        historyLength /= summedWeight;
        
        float rawHistoryAlpha = 1.f / (historyLength + 1.f);
        float colorAlpha = max(PushC.MinNewDataWeight, rawHistoryAlpha);
        float momentsAlpha = max(0.6, rawHistoryAlpha);

        colorAlpha = mix(colorAlpha, 1.0, antilagAlpha);
        momentsAlpha = mix(momentsAlpha, 1.0, antilagAlpha);

        vec4 accuColorPlusHistlen = vec4(mix(prevColor, currColor, colorAlpha), historyLength + 1.f);
        imageStore(AccumulatedColor, ivec3(currTexel, PushC.WriteIdx), accuColorPlusHistlen);
        vec4 accuMoments = vec4(mix(prevMoments, currMoments, momentsAlpha), 0, 0);
        imageStore(AccumulatedMoments, ivec3(currTexel, PushC.WriteIdx), accuMoments);
        historyLength = min(64, historyLength + 1.f);
        imageStore(AccumulatedHistoryLength, ivec3(currTexel, PushC.WriteIdx), vec4(historyLength, 0, 0, 0));
        if (PushC.DebugMode == DEBUG_TEMPACCU_OUTPUT)
        {
            imageStore(DebugOutput, currTexel, vec4(mix(prevColor, currColor, colorAlpha), 1.f));
        }
        if (PushC.DebugMode == DEBUG_TEMPACCU_ALPHA)
        {
            imageStore(DebugOutput, currTexel, vec4(colorAlpha, momentsAlpha, 0.f, 1.f));
        }
    }
    else
    {
        imageStore(AccumulatedColor, ivec3(currTexel, PushC.WriteIdx), vec4(currColor, 1.f));
        imageStore(AccumulatedMoments, ivec3(currTexel, PushC.WriteIdx), vec4(currMoments, 0, 0));
        imageStore(AccumulatedHistoryLength, ivec3(currTexel, PushC.WriteIdx), vec4(1.f, 0, 0, 0));
        if (PushC.DebugMode == DEBUG_TEMPACCU_OUTPUT)
        {
            imageStore(DebugOutput, currTexel, vec4(currColor, 1.f));
        }
        if (PushC.DebugMode == DEBUG_TEMPACCU_ALPHA)
        {
            imageStore(DebugOutput, currTexel, vec4(0.f, 0.f, 0.f, 1.f));
        }
    }
    if (PushC.DebugMode == DEBUG_TEMPACCU_WEIGHTS)
    {
        imageStore(DebugOutput, currTexel, vec4(summedWeight / 10, 0, 0, 1));
    }
}