#version 430
#extension GL_KHR_vulkan_glsl : enable
#extension GL_GOOGLE_include_directive : enable

#include "asvgf_shared.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

//Inputs
layout(rgba32f, binding = 0) uniform readonly image2D PrimaryInput;

layout(r16ui, binding = 1) uniform uimage2D Seed;

layout(rgba32f, binding = 2) uniform readonly image2D HistoryPrimaryInput;

layout(rg32f, binding = 3) uniform readonly image2D GbufferLinearZ;

layout(r32ui, binding = 4) uniform readonly uimage2D GbufferMeshInstanceIdx;

layout(r32ui, binding = 5) uniform readonly uimage2D NoiseTexture;

//Outputs
layout(rg32f, binding = 6) uniform writeonly image2D LuminanceMaxDiff;

layout(rgba32f, binding = 7) uniform writeonly image2D MomentsLinZ;

layout(push_constant) uniform push_constant_t
{
    uint FrameIdx;
} PushC;

const uint TILEMASK = (1 << 3) - 1;

void main()
{
    const ivec2 strataPos = ivec2(gl_GlobalInvocationID.xy);

    uint seed = imageLoad(Seed, strataPos).x;

    {
        //Generate Seed Value
        uint newseed = imageLoad(NoiseTexture, strataPos).x + PushC.FrameIdx;
        seed = (seed << 6) | (newseed & ((1 << 6) - 1));
    }

    // Position inside the 3x3 tile
	ivec2 tilePos = ivec2((seed & TILEMASK), (seed >> 3) & TILEMASK) % 3;

    ivec2 texelPos = strataPos * 3 + tilePos;

    // current frame luminance
    float luminance = calcLuminance(imageLoad(PrimaryInput, texelPos).rgb);

    {
        uint oldSeed = (seed >> 6);

        // Position inside the 3x3 tile
	    ivec2 tilePos = ivec2((oldSeed & TILEMASK), (oldSeed >> 3) & TILEMASK) % 3;

        ivec2 texelPos = strataPos * 3 + tilePos;

        // previous frame luminance
        float prevLuminance = calcLuminance(imageLoad(HistoryPrimaryInput, texelPos).rgb);

        float maxLuminance = max(luminance, prevLuminance);

        imageStore(LuminanceMaxDiff, strataPos, vec4(maxLuminance, luminance - prevLuminance, 0.0, 0.0));
    }

    vec2 moments = vec2(luminance, luminance * luminance);
	// Weight
	float sum_w = 1.0;
	// Linear Z
	vec2 linearZ = imageLoad(GbufferLinearZ, texelPos).rg;
	// Mesh Id
	uint mesh_id  = imageLoad(GbufferMeshInstanceIdx, texelPos).x;

    int gradientDownsample = 3;
    // For a 3x3 kernel (Current Tile)
    for(int yy = 0; yy < gradientDownsample; yy++) {
	    for(int xx = 0; xx < gradientDownsample; xx++) {
			// Current position in kernel
			ivec2 samplePos = strataPos * gradientDownsample + ivec2(xx, yy);
			// If not the already looked at position
			if(texelPos != samplePos) {
				// Get noisy color
				vec3 rgb = imageLoad(PrimaryInput, samplePos).rgb;
				// Get Mesh id
				uint mesh_id_samplePos = imageLoad(GbufferMeshInstanceIdx, samplePos).x;
				float l = calcLuminance(rgb);
				// Weight 1 only if same mesh
				float w = mesh_id_samplePos == mesh_id ? 1.0 : 0.0;
				// sum up moments
				moments += vec2(l, l * l) * w;
				// sum up weights
				sum_w += w;
			}
		}
	}

    // divide by weights: moments is now an average of vec2[luminance, luminance^2] for the current tile
	moments /= sum_w;

	// Calculate variance across the tile. Single high values compared to average equals higher variance.
	float variance = max(0.0, moments.y - moments.x * moments.x);

	imageStore(MomentsLinZ, strataPos, vec4(moments.x, variance, linearZ.x, linearZ.y));
}